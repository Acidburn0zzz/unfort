const {isObject} = require('lodash/lang');
const traverse = require('babel-traverse').default;
const types = require('babel-types');

const COMMONJS = 'COMMONJS';
const ES_MODULE = 'ES_MODULE';

module.exports = {
  COMMONJS,
  ES_MODULE,
  babylonAstDependencies
};

/**
 * Given an AST generated by babylon, returns an object describing
 * the imports, exports and any errors encountered.
 *
 * Accepts a `resolveModuleIdentifier` option that allows dependencies
 * to be rewritten within the AST
 */
function babylonAstDependencies(ast, options={}) {
  if (!isObject(ast)) {
    throw new Error('An `ast` must be provided');
  }

  const resolveModuleIdentifier = options.resolveModuleIdentifier || null;

  const outcome = {
    dependencies: [],
    exports: []
  };

  traverse(ast, {
    ImportDeclaration(node) {
      node = node.node;
      // `import ... from '...';
      addEsModuleDependency(outcome, resolveModuleIdentifier, node);
    },
    ExportDeclaration(node) {
      node = node.node;
      // `export ... from '...';
      if (node.source) {
        addEsModuleDependency(outcome, resolveModuleIdentifier, node);
      }
      // `export default ...`
      if (node.type === 'ExportDefaultDeclaration') {
        addEsModuleExport(outcome, null, true);
      // `export ... from '...'`;
      } else if (node.specifiers.length) {
        node.specifiers.forEach(obj => addEsModuleExport(outcome, obj.local.name, false));
      // `export const ...`;
      } else if (node.declaration && node.declaration.type === 'VariableDeclaration') {
        addEsModuleExport(outcome, node.declaration.declarations[0].id.name, false);
      }
    },
    /*
      TODO
      accept `supportCommonJS` option to turn off needless checks?
      if there are no calls to check, we can also simply traverse the
      lowest level of the ast (rather than every node), so traversal
      may become much faster. Might be as simple as `/require/.test(code)`
     */
    CallExpression(node) {
      node = node.node;
      // `require('...');
      if (node.callee.name === 'require') {
        const arg = node.arguments[0];
        if (types.isLiteral(arg)) {
          const identifier = arg.value;
          addCommonJSDependency(outcome, identifier);
          if (resolveModuleIdentifier) {
            arg.value = resolveModuleIdentifier(identifier);
            appendIdentifierCommentBlock(node, identifier);
          }
        } else {
          if (!arg.loc || !arg.loc.start) {
            throw new Error('Require expression cannot be statically analyzed');
          }
          const err = new Error(
            `require(...) expression at line ${arg.loc.start.line}, column ${arg.loc.start.column} ` +
            'cannot be statically analyzed'
          );

          // Enable errors to be mapped against the text's content
          err.loc = {
            line: arg.loc.start.line,
            column: arg.loc.start.column
          };

          throw err;
        }
      }
    }
  });

  return outcome;
}

function addCommonJSDependency(outcome, identifier) {
  outcome.dependencies.push({
    type: COMMONJS,
    identifier
  });
}

function addEsModuleDependency(outcome, resolveModuleIdentifier, node) {
  const specifiers = getEsModuleImportSpecifiers(node);

  const identifier = node.source.value;
  outcome.dependencies.push({
    type: ES_MODULE,
    identifier,
    specifiers
  });

  if (resolveModuleIdentifier) {
    node.source.value = resolveModuleIdentifier(identifier);
    appendIdentifierCommentBlock(node, identifier);
  }
}

function getEsModuleImportSpecifiers(node) {
  return node.specifiers.map(node => {
    return {
      name: node.local.name,
      isDefault: node.type === 'ImportDefaultSpecifier'
    };
  });
}

function addEsModuleExport(outcome, name, isDefault) {
  outcome.exports.push({
    type: ES_MODULE,
    name,
    isDefault
  });
}

function appendIdentifierCommentBlock(node, identifier) {
  node.trailingComments = node.trailingComments || [];
  node.trailingComments.push({
    type: 'CommentBlock',
    value: ` ${identifier} `
  });
}