import path from 'path';
import imm from 'immutable';
import {createMockCache} from 'kv-cache';

export const bootstrapRuntime = require.resolve('../runtimes/bootstrap');
export const hotRuntime = require.resolve('../runtimes/hot');
export const vendorRoot = path.normalize(path.join(__dirname, '..', 'vendor'));

/**
 * The `state` object passed around, most commonly via `getState`.
 *
 * An immutable record that contains a mixture of configuration, generated
 * data, and references to stateful sub-modules
 */
export const State = imm.Record({
  // ===================
  // Build configuration
  // ===================

  // The dependency graph's entry points
  entryPoints: null,
  // The root of your project
  sourceRoot: null,
  // The root `node_modules` directory that your modules are pulled from
  rootNodeModules: null,
  // The root directory that cached data will be dumped into
  cacheDirectory: null,
  // The record store's jobs
  jobs: null,
  // The directory containing the hot runtime's vendor packages
  vendorRoot,
  rootUrl: null,
  getSockets: null,


  // ================
  // Environment hash
  // ================

  // Options passed to `envHash`
  envHash: null,
  // The hash generated by `envHash`
  environmentHash: null,


  // =================
  // The module system
  // =================

  bootstrapRuntime,
  hotRuntime,

  // ===================
  // Stateful subsystems
  // ===================

  recordStore: null,
  jobCache: null,
  graph: null,
  watchers: null,

  // =======
  // Loggers
  // =======

  // We use wrappers around the console object so that we can prevent
  // output during tests
  logInfo: function() {
    console.info.apply(console, arguments);
  },
  logError: function() {
    console.error.apply(console, arguments);
  },


  // =============================
  // Data generated from the build
  // =============================

  // Any errors that have blocked a build
  errors: null,
  // The latest snapshot of the dependency graph
  nodes: null,
  // The latest snapshot of the record store
  records: null,
  // Used by the file endpoint for resolving content
  recordsByUrl: null,
  // Used by the file endpoint for resolving source maps
  recordsBySourceMapUrl: null
});

/**
 * Creates a state object and sets defaults for required values
 *
 * @param {Object} overrides
 */
export function createState(overrides={}) {
  let state = State(overrides);

  if (!state.getSockets) {
    state = state.set('getSockets', () => []);
  }

  if (!state.sourceRoot) {
    state = state.set('sourceRoot', process.cwd());
  }

  if (!state.rootNodeModules) {
    state = state.set('rootNodeModules', path.join(state.sourceRoot, 'node_modules'));
  }

  if (!state.cacheDirectory) {
    state = state.set('cacheDirectory', path.join(state.sourceRoot, '.unfort'));
  }

  if (!state.entryPoints) {
    state = state.set('entryPoints', []);
  }

  if (!state.jobCache) {
    state = state.set('jobCache', createMockCache());
  }

  return state;
}
