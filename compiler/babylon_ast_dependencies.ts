import { isObject, uniq } from 'lodash';
import traverse from 'babel-traverse';
import * as types from 'babel-types';
import { CodeError } from '../common';

/**
 * Given an AST generated by babylon, returns an object describing
 * the imports, exports and any errors encountered.
 */
export function babylonAstDependencies(ast: any, options?: {text?: string}) {
  const outcome = {
    identifiers: []
  };

  let checkForRequires = true;
  let checkForImports = true;
  let checkForExports = true;
  if (options && options.text) {
    const text = options.text;
    checkForRequires = text.indexOf('require') !== -1;
    checkForImports = text.indexOf('import') !== -1;
    checkForExports = text.indexOf('export') !== -1;
    if (!checkForRequires && !checkForImports && !checkForExports) {
      return outcome;
    }
  }

  const visitor: any = {};
  if (checkForRequires) {
    visitor.CallExpression = (node) => handlePossibleRequireCallExpression(outcome, node);
  }
  if (checkForImports) {
    visitor.ImportDeclaration = (node) => handleImportDeclaration(outcome, node);
  }
  if (checkForExports) {
    visitor.ExportDeclaration = (node) => handleExportDeclaration(outcome, node);
  }
  traverse(ast, visitor);

  outcome.identifiers = uniq(outcome.identifiers);

  return outcome;
}

function handleImportDeclaration(outcome, node) {
  node = node.node;
  // `import ... from '...';
  outcome.identifiers.push(node.source.value);
}

function handleExportDeclaration(outcome, node) {
  node = node.node;
  // `export ... from '...';
  if (node.source) {
    outcome.identifiers.push(node.source.value);
  }
}

function handlePossibleRequireCallExpression(outcome, node) {
  node = node.node;
  // `require('...');
  if (node.callee.name === 'require') {
    const arg = node.arguments[0];
    if (types.isLiteral(arg)) {
      const identifier = arg.value;
      outcome.identifiers.push(identifier);
      return;
    } else {
      if (!arg.loc || !arg.loc.start) {
        throw new Error('Require expression cannot be statically analyzed');
      } else {
        const err = new CodeError(
          `require(...) expression at line ${arg.loc.start.line}, column ${arg.loc.start.column} ` +
          'cannot be statically analyzed'
        );
        // Enable errors to be mapped against the text's content
        err.loc = {
          line: arg.loc.start.line,
          column: arg.loc.start.column
        };
        throw err;
      }
    }
  }
}