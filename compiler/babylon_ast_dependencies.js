"use strict";

const {isObject} = require('lodash/lang');
const traverse = require('babel-traverse').default;
const types = require('babel-types');

const COMMONJS = 'COMMONJS';
const ES_MODULE = 'ES_MODULE';

const REQUIRE = /require/;
const IMPORT = /import/;
const EXPORT = /export/;

/**
 * Given an AST generated by babylon, returns an object describing
 * the imports, exports and any errors encountered.
 *
 * Accepts a `resolveModuleIdentifier` option that allows dependencies
 * to be rewritten within the AST
 */
function babylonAstDependencies(ast, options={}) {
  if (!isObject(ast)) {
    throw new Error('An abstract syntax tree must be provided as the first argument');
  }

  const {
    resolveModuleIdentifier=null,
    text=null,
  } = options;

  const outcome = {
    dependencies: [],
    exports: []
  };

  let checkForRequires = true;
  let checkForImports = true;
  let checkForExports = true;
  if (text) {
    checkForRequires = REQUIRE.test(text);
    checkForImports = IMPORT.test(text);
    checkForExports = EXPORT.test(text);
    if (!checkForRequires && !checkForImports && !checkForExports) {
      return outcome;
    }
  }

  const visitor = {};
  if (checkForRequires) {
    visitor.CallExpression = (node) => {
      return handlePossibleRequireCallExpression(outcome, resolveModuleIdentifier, node);
    };
  }
  if (checkForImports) {
    visitor.ImportDeclaration = (node) => {
      return handleImportDeclaration(outcome, resolveModuleIdentifier, node);
    };
  }
  if (checkForExports) {
    visitor.ExportDeclaration = (node) => {
      return handleExportDeclaration(outcome, resolveModuleIdentifier, node);
    };
  }
  traverse(ast, visitor);

  return outcome;
}

function handleImportDeclaration(outcome, resolveModuleIdentifier, node) {
  node = node.node;
  // `import ... from '...';
  addEsModuleDependency(outcome, resolveModuleIdentifier, node);
}

function handleExportDeclaration(outcome, resolveModuleIdentifier, node) {
  node = node.node;
  // `export ... from '...';
  if (node.source) {
    addEsModuleDependency(outcome, resolveModuleIdentifier, node);
  }
  // `export default ...`
  if (node.type === 'ExportDefaultDeclaration') {
    addEsModuleExport(outcome, null, true);
    // `export ... from '...'`;
  } else if (node.specifiers.length) {
    node.specifiers.forEach(obj => addEsModuleExport(outcome, obj.local.name, false));
    // `export const ...`;
  } else if (node.declaration && node.declaration.type === 'VariableDeclaration') {
    addEsModuleExport(outcome, node.declaration.declarations[0].id.name, false);
  }
}

function handlePossibleRequireCallExpression(outcome, resolveModuleIdentifier, node) {
  node = node.node;
  // `require('...');
  if (node.callee.name === 'require') {
    const arg = node.arguments[0];
    if (types.isLiteral(arg)) {
      const identifier = arg.value;
      addCommonJSDependency(outcome, identifier);
      if (resolveModuleIdentifier) {
        arg.value = resolveModuleIdentifier(identifier);
        appendIdentifierCommentBlock(node, identifier);
      }
    } else {
      if (!arg.loc || !arg.loc.start) {
        throw new Error('Require expression cannot be statically analyzed');
      }
      const err = new Error(
        `require(...) expression at line ${arg.loc.start.line}, column ${arg.loc.start.column} ` +
        'cannot be statically analyzed'
      );

      // Enable errors to be mapped against the text's content
      err.loc = {
        line: arg.loc.start.line,
        column: arg.loc.start.column
      };

      throw err;
    }
  }
}

function addCommonJSDependency(outcome, identifier) {
  outcome.dependencies.push({
    type: COMMONJS,
    identifier
  });
}

function addEsModuleDependency(outcome, resolveModuleIdentifier, node) {
  const specifiers = getEsModuleImportSpecifiers(node);

  const identifier = node.source.value;
  outcome.dependencies.push({
    type: ES_MODULE,
    identifier,
    specifiers
  });

  if (resolveModuleIdentifier) {
    node.source.value = resolveModuleIdentifier(identifier);
    appendIdentifierCommentBlock(node, identifier);
  }
}

function getEsModuleImportSpecifiers(node) {
  return node.specifiers.map(node => {
    return {
      name: node.local.name,
      isDefault: node.type === 'ImportDefaultSpecifier'
    };
  });
}

function addEsModuleExport(outcome, name, isDefault) {
  outcome.exports.push({
    type: ES_MODULE,
    name,
    isDefault
  });
}

function appendIdentifierCommentBlock(node, identifier) {
  node.trailingComments = node.trailingComments || [];
  node.trailingComments.push({
    type: 'CommentBlock',
    value: ` ${identifier} `
  });
}

module.exports = {
  COMMONJS,
  ES_MODULE,
  babylonAstDependencies
};